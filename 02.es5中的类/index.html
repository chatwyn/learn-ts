<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>

    <script>
        
        //es5里的类


        // 1. 最简单的类
        // function Person() {
        //     this.name = "自己阿迷和萨满";
        //     this.age = 20;
        // }

        // var p = new Person()
        // alert(p.name);


        // 2.构造函数中添加方法

        // function Person() {
        //     this.name = "张三";
        //     this.age = 20;

        //     this.run = function() {
        //         alert(this.name + "在远动");
        //     }
        // }

        // // 原型链上面的属性会被多个实例共享  构造函数不会
        // Person.prototype.sex = "男";
        // Person.prototype.work = function() {
        //     alert(this.name + "在工作");
        // }

        // var p = new Person()
        // p.work();

// 3. 类里边的静态方法
        // function Person() {
        //     this.name = "张三";
        //     this.age = 20;

        //     this.run = function() {
        //         alert(this.name + "在远动");
        //     }
        // }

        // Person.getInfo = function() {
        //     alert("我是静态方法")
        // }

        // Person.getInfo();
        
    // // 4. es5里的继承 对象冒充实现继承
    //     function Person() {
    //         this.name = "张三";
    //         this.age = 20;

    //         this.run = function() {
    //             alert(this.name + "在远动");
    //         }
    //     }

    //     // 原型链上面的属性会被多个实例共享  构造函数不会
    //     Person.prototype.sex = "男";
    //     Person.prototype.work = function() {
    //         alert(this.name + "在工作");
    //     }


    //     //web类继承Person类   原型链，对象冒充的组合继承模式

    //     function Web() {
    //         Person.call(this); //对象冒充实现继承
    //     }

    //     var w = new Web();
    //     w.run(); //对象冒充可以继承构造函数里的属性和方法    

    //     w.work(); // 不可以继承原型链上的属性和方法

        
    //  // 5. es5里的继承 原型链实现继承
    //  function Person() {
    //         this.name = "张三";
    //         this.age = 20;

    //         this.run = function() {
    //             alert(this.name + "在远动");
    //         }
    //     }

    //     // 原型链上面的属性会被多个实例共享  构造函数不会
    //     Person.prototype.sex = "男";
    //     Person.prototype.work = function() {
    //         alert(this.name + "在工作");
    //     }


    //     //web类继承Person类   原型链，对象冒充的组合继承模式

    //     function Web() {

    //     }

    //     Web.prototype = new Person(); // 原型链实现继承

    //     var w = new Web();
    //     //原型链实现继承；可以继承构造函数里的属性和方法， 也可以继承原型链上的属性和方法
    //     w.run();
    //     w.work();


    //  // 6. es5里的继承 原型链实现继承的问题 ？？？
    //  function Person(name, age) {
    //         this.name = name;
    //         this.age = age;

    //         this.run = function() {
    //             alert(this.name + "在远动");
    //         }
    //     }

    //     // 原型链上面的属性会被多个实例共享  构造函数不会
    //     Person.prototype.sex = "男";
    //     Person.prototype.work = function() {
    //         alert(this.name + "在工作");
    //     }



    //     function Web(name, age) {

    //     }

    //     Web.prototype = new Person(); // 原型链实现继承

    //     var w = new Web("赵四", 20);   // 实例化子类的时候没法给父类传参
    //     w.run()  // name  undefined

    

    //  // 7. es5里的继承 原型链和对象冒充实现继承的组合
    //  function Person(name, age) {
    //         this.name = name;
    //         this.age = age;

    //         this.run = function() {
    //             alert(this.name + "在远动");
    //         }
    //     }

    //     // 原型链上面的属性会被多个实例共享  构造函数不会
    //     Person.prototype.sex = "男";
    //     Person.prototype.work = function() {
    //         alert(this.name + "在工作");
    //     }



    //     function Web(name, age) {
    //         Person.call(this, name, age);  //对象冒充继承  实例化子类可以给父类传参
    //     }

    //     Web.prototype = new Person(); // 原型链实现继承

    //     var w = new Web("赵四", 20);   // 实例化子类的时候没法给父类传参
    //     w.run();
    //     w.work();


      // 8. es5里的继承 原型链和对象冒充实现继承的组合的另一种方式
      function Person(name, age) {
            this.name = name;
            this.age = age;

            this.run = function() {
                alert(this.name + "在远动");
            }
        }

        // 原型链上面的属性会被多个实例共享  构造函数不会
        Person.prototype.sex = "男";
        Person.prototype.work = function() {
            alert(this.name + "在工作");
        }



        function Web(name, age) {
            Person.call(this, name, age);  //对象冒充继承  可以继承构造函数里面的属性和方法 实例化子类可以给父类传参
        }

        Web.prototype = Person.prototype; 

        var w = new Web("赵四", 20);   // 实例化子类的时候没法给父类传参
        w.run();
        w.work();

    </script>


</head>

<body>
    <div id="box">
        box
    </div>
</body>

</html>

<!-- <script src="js/hello.js"></script> -->